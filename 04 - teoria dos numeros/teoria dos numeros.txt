Qualquer numero inteiro que nao seja primo tem pelo menos um divisor maior que 1
e menor ou igual a raiz desse numero.

-> se n % a == 0
-> entao a eh um divsor de n e n / a -> b sera o segundo divisor desse numero
a menos que b seja igual a a.

Os divisores de um numero aparecem aos pares.


//GCD -> Greates common divisor
GCD(a,b)=GCD(b, a mod b) esta eh a base do algoritmo
do Euclides que nos permite determinar o GCD entre divisores
numeros

//LCM -> Least common multiple
Pela Teoria dos numeros temos a seguinte formula
ğ‘™ğ‘ğ‘š (ğ‘, ğ‘) = ğ‘Ã—ğ‘ / gcd(ğ‘,ğ‘)

//binary exponentiation

//Aritmetica modular
A expressÃ£o ğ‘ â‰¡ ğ‘ ğ‘šğ‘œğ‘‘ ğ‘š significa que a e b sÃ£o equivalentes mod m, em programaÃ§Ã£o, isso Ã© o
mesmo que dizer que a seguinte expressÃ£o booleana Ã© verdadeira: a%m==b%m.
â¢ Exemplo: 42 â‰¡ 10 (ğ‘šğ‘œğ‘‘ 8)

A aritmÃ©tica modular possui algumas propriedades interessantes:
â¢ (a+b)%m=(a%m+b%m)%m
â¢ (a-b)%m=(a%m-b%m+m)%m
â¢ (a*b)%m=(a%m*b%m)%m
â¢ (a/b)%m=(a%m*ModInverse(b,m)%m)%m, ModInverse(b,m) Ã© um x tal que ğ›ğ± â‰¡ ğŸ ğ’ğ’ğ’… ğ’
â¢ Se m Ã© coprimo de b, isto Ã©, GCD(m,b)=1 (que Ã© o caso comum em problemas de programaÃ§Ã£o
competitiva) entÃ£o ModInverse(b,m) = binPow(b,m-2)%m (sem esquecer de modular dentro
de binPow para evitar overflow).
